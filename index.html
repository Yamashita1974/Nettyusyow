<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>熱中症リスク予報</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* 基本のフォント設定 */
        body {
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
            transition: background-color 0.3s, color 0.3s;
        }
        /* ダークモード設定 */
        .dark {
            color-scheme: dark;
        }
        .dark body {
            background-color: #111827; /* gray-900 */
            color: #d1d5db; /* gray-300 */
        }
        .dark .bg-white {
            background-color: #1f2937; /* gray-800 */
        }
        .dark .bg-gray-100 {
            background-color: #374151; /* gray-700 */
        }
        .dark .bg-gray-200 {
             background-color: #4b5563; /* gray-600 */
        }
        .dark .text-gray-800 {
            color: #f9fafb; /* gray-50 */
        }
        .dark .text-gray-700 {
            color: #d1d5db; /* gray-300 */
        }
        .dark .text-gray-600 {
            color: #9ca3af; /* gray-400 */
        }
         .dark .text-gray-500 {
            color: #6b7280; /* gray-500 */
        }
        .dark .border-gray-300 {
            border-color: #4b5563; /* gray-600 */
        }
        .dark .hover\:bg-gray-50:hover {
            background-color: #374151; /* gray-700 */
        }
        .dark .wbgt-table th:first-child, .dark .wbgt-table td:first-child {
            background-color: #374151; /* gray-700 */
        }
        .dark .wbgt-table thead th {
             background-color: #4b5563; /* gray-600 */
        }
        /* --- FIX START: 早見表のテキスト色を修正 --- */
        .dark .wbgt-table th,
        .dark .wbgt-table td:first-child {
            color: #f9fafb; /* gray-50 */
        }
        .dark .wbgt-table td {
             color: #1f2937; /* gray-800 */
        }
        /* --- FIX END --- */
        .dark .source-table th {
            background-color: #374151; /* gray-700 */
        }
        .dark .source-table th, .dark .source-table td {
             border-color: #4b5563; /* gray-600 */
        }


        /* ゲージのアニメーション */
        .gauge-meter {
            stroke-linecap: round;
            transition: stroke-dashoffset 1s ease-out;
        }
        /* モーダルのトランジション */
        .modal {
            transition: opacity 0.3s ease;
        }
        /* 早見表のスタイル */
        .wbgt-table th, .wbgt-table td {
            text-align: center;
            padding: 0.5rem;
            font-size: 0.8rem;
            min-width: 50px;
        }
        .wbgt-table th:first-child, .wbgt-table td:first-child {
            font-weight: 600;
            background-color: #f9fafb;
            position: sticky;
            left: 0;
            z-index: 10;
        }
        .wbgt-table thead th {
            position: sticky;
            top: 0;
            background-color: #f3f4f6;
            z-index: 20;
        }
        /* ハイライト表示 */
        .highlight-cell {
            position: relative;
            box-shadow: inset 0 0 0 3px #3b82f6;
            z-index: 30;
        }
        .source-table th, .source-table td {
            border: 1px solid #d1d5db;
            padding: 8px;
            text-align: left;
        }
        /* ローディング中のブラー効果 */
        .content-loading {
            filter: blur(4px);
            opacity: 0.6;
            transition: filter 0.3s, opacity 0.3s;
        }
        /* ローディングオーバーレイ */
        .loader-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.7);
            z-index: 9998;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .dark .loader-overlay {
            background-color: rgba(17, 24, 39, 0.7);
        }

        /* 危険度テキストのアニメーション */
        @keyframes flash {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.05); }
        }
        .animate-flash {
            animation: flash 0.5s ease-in-out;
        }

        /* 予報カードのフェードインアニメーション */
        .forecast-card {
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.5s ease-out, transform 0.5s ease-out;
        }
        .forecast-card.visible {
            opacity: 1;
            transform: translateY(0);
        }
    </style>
</head>
<body class="bg-gray-100">
    <div id="loader" class="loader-overlay hidden">
        <i class="fas fa-spinner fa-spin fa-3x text-blue-500"></i>
        <p class="mt-4 text-gray-600 font-semibold">データを取得中...</p>
    </div>

    <div id="app-container" class="max-w-2xl mx-auto p-4 sm:p-6 lg:p-8">
        
        <!-- ヘッダー -->
        <header class="relative text-center mb-6">
            <h1 class="text-3xl font-bold text-gray-800">熱中症リスク予報</h1>
            <p class="text-sm text-gray-500 mt-1">相生エンジニアリング株式会社の安全内規に準拠</p>
            <!-- ダークモードトグル -->
            <button id="theme-toggle" class="absolute top-0 right-0 p-2 text-lg text-gray-500 hover:text-blue-500 dark:hover:text-yellow-300 transition-colors">
                <i id="theme-icon" class="fas fa-moon"></i>
            </button>
        </header>

        <!-- 場所検索 -->
        <div class="bg-white rounded-xl shadow-md p-4 mb-4">
            <div class="flex flex-col sm:flex-row gap-2">
                <input type="text" id="cityInput" placeholder="例: 東京都千代田区" class="flex-grow w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                <div class="flex gap-2">
                    <button id="searchBtn" class="w-full sm:w-auto bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors flex items-center justify-center gap-2">
                        <i class="fas fa-search"></i> <span>検索</span>
                    </button>
                    <button id="gpsBtn" class="w-full sm:w-auto bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700 transition-colors flex items-center justify-center gap-2">
                        <i class="fas fa-location-arrow"></i> <span>現在地</span>
                    </button>
                </div>
            </div>
        </div>

        <!-- 検索履歴 -->
        <div id="historyContainer" class="flex flex-wrap gap-2 mb-6 justify-center">
            <!-- History buttons will be inserted here -->
        </div>
        
        <!-- エラーメッセージ -->
        <div id="error-message" class="hidden bg-red-100 border-l-4 border-red-500 text-red-700 p-4 rounded-md mb-6" role="alert">
            <p class="font-bold">エラー</p>
            <p id="error-text"></p>
        </div>

        <!-- メインコンテンツ -->
        <div id="main-content">
            <!-- 現在の状況 -->
            <div class="bg-white rounded-xl shadow-lg p-6 mb-6">
                <h2 id="locationName" class="text-2xl font-bold text-gray-800 text-center mb-4">--</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 items-center">
                    <!-- WBGTゲージ -->
                    <div class="relative w-48 h-48 mx-auto">
                        <svg class="w-full h-full" viewBox="0 0 36 36">
                            <path class="gauge-bg" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" fill="none" stroke-width="3.8"></path>
                            <path id="gaugeMeter" class="gauge-meter" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" fill="none" stroke-width="3.8" stroke-dasharray="100, 100" stroke-dashoffset="100"></path>
                        </svg>
                        <div class="absolute inset-0 flex flex-col items-center justify-center">
                            <span class="text-xs text-gray-500">WBGT推定値</span>
                            <span id="currentWbgt" class="text-5xl font-bold">--</span>
                            <span class="text-xs text-gray-500">℃</span>
                        </div>
                    </div>
                    <!-- リスク情報 -->
                    <div class="text-center md:text-left">
                        <p id="riskLevelText" class="text-3xl font-bold mb-2">---</p>
                        <p class="text-gray-600 mb-4">現在の気象情報:</p>
                        <!-- 日時表示 -->
                        <p id="currentDateTime" class="text-sm text-gray-500 -mt-3 mb-3">-- 時点</p>
                        <div class="flex justify-center md:justify-start gap-4 text-gray-700">
                            <div class="flex items-center gap-2">
                                <i class="fas fa-temperature-high text-red-500"></i>
                                <span id="currentTemp">--℃</span>
                            </div>
                            <div class="flex items-center gap-2">
                                <i class="fas fa-tint text-blue-500"></i>
                                <span id="currentHumidity">--%</span>
                            </div>
                        </div>
                         <div class="mt-4 border-t pt-4">
                            <p id="maxWbgtLabel" class="text-sm font-semibold text-gray-700">今日の最高WBGT (9-17時)</p>
                            <p class="text-xl font-bold text-red-600">
                                <span id="maxWbgtValue">--</span>℃
                                <span class="text-sm font-medium text-gray-500" id="maxWbgtTime">(--:--)</span>
                            </p>
                            <div class="flex justify-center md:justify-start gap-4 text-sm text-gray-600 mt-1">
                                <div class="flex items-center gap-1">
                                    <i class="fas fa-temperature-high text-red-400"></i>
                                    <span id="maxWbgtTemp">--℃</span>
                                </div>
                                <div class="flex items-center gap-1">
                                    <i class="fas fa-tint text-blue-400"></i>
                                    <span id="maxWbgtHumidity">--%</span>
                                </div>
                            </div>
                        </div>
                        <button id="openModalBtn" class="mt-4 w-full md:w-auto bg-gray-700 text-white px-4 py-2 rounded-lg hover:bg-gray-800 transition-colors flex items-center justify-center gap-2">
                            <i class="fas fa-info-circle"></i> <span>凡例</span>
                        </button>
                    </div>
                </div>
            </div>

            <!-- WBGT早見表 -->
            <div class="bg-white rounded-xl shadow-md p-6 mb-6">
                 <button id="toggleTableBtn" class="w-full text-left text-xl font-bold text-gray-800 mb-4 flex justify-between items-center">
                    <span>WBGT早見表 (温度/湿度)</span>
                    <i id="tableCaret" class="fas fa-chevron-down transition-transform"></i>
                </button>
                <div id="wbgtTableContainer" class="hidden overflow-x-auto">
                    <table class="w-full border-collapse wbgt-table">
                        <thead id="wbgtTableHeader"></thead>
                        <tbody id="wbgtTableBody"></tbody>
                    </table>
                </div>
                <!-- 注釈を追加 -->
                <p class="text-xs text-gray-500 mt-2 pl-1">
                    ※早見表は一般的な参考値です。ハイライトされたマスの値は、現在の気象情報から計算された画面中央の推定値とは異なる場合があります。
                </p>
            </div>

            <!-- 時間別予報 -->
            <div class="bg-white rounded-xl shadow-md p-6 mb-6">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-bold text-gray-800">時間別予報 (24時間)</h3>
                    <button id="toggle-forecast-view" class="p-2 text-lg text-gray-500 hover:text-blue-500">
                        <i id="forecast-view-icon" class="fas fa-chart-line"></i>
                    </button>
                </div>
                 <div id="hourly-chart-container" class="hidden" style="height: 250px;">
                    <canvas id="hourlyChartCanvas"></canvas>
                </div>
                <div id="hourly-cards-container" class="overflow-x-auto">
                    <div id="hourlyForecast" class="flex space-x-4 pb-2">
                        <!-- Hourly cards will be inserted here -->
                    </div>
                </div>
            </div>

            <!-- 週間予報 -->
            <div class="bg-white rounded-xl shadow-md p-6">
                <h3 class="text-xl font-bold text-gray-800 mb-4">週間予報</h3>
                <div id="dailyForecast" class="space-y-3">
                    <!-- Daily items will be inserted here -->
                </div>
            </div>
            
            <!-- 免責事項 -->
            <div class="text-center mt-8">
                <p class="text-xs text-gray-500">
                    ※本アプリが提供するWBGT(暑さ指数)は、公開されている気象データから独自の手法で推定した参考値です。<br>
                    実際の作業環境のWBGT値とは異なる場合があります。必ず現地の状況を確認し、安全を最優先してください。
                </p>
            </div>
        </div>
    </div>

    <!-- 凡例モーダル -->
    <div id="safetyModal" class="modal fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50 opacity-0 pointer-events-none">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-lg max-h-[90vh] overflow-y-auto">
            <div id="modalContent" class="p-6">
                <!-- Modal content will be inserted here -->
            </div>
        </div>
    </div>


<script>
// --- CONFIGURATION ---
const API_KEY = "f8139ad62e30fe98dca264701ef32699"; 

const RISK_LEVELS = {
    DANGER: { level: '危険', color: '#ef4444', textColor: 'text-red-500', bgColor: 'bg-red-500', tableBgColor: 'bg-red-200' },
    SEVERE_VIGILANCE: { level: '厳重警戒', color: '#f97316', textColor: 'text-orange-500', bgColor: 'bg-orange-500', tableBgColor: 'bg-orange-200' },
    VIGILANCE: { level: '警戒', color: '#f59e0b', textColor: 'text-yellow-500', bgColor: 'bg-yellow-500', tableBgColor: 'bg-yellow-200' },
    CAUTION: { level: '注意', color: '#22c55e', textColor: 'text-green-500', bgColor: 'bg-green-500', tableBgColor: 'bg-green-200' }
};

const SOURCE_DATA = [
    { wbgt: "31～", level: "危険", detail: "すべての生活活動で熱中症の危険性。高齢者においては安静状態でも発生する危険性が大きい。外出はなるべく避け、涼しい室内に移動する。" },
    { wbgt: "28～31", level: "厳重警戒", detail: "外出時は炎天下を避け、室内では室温の上昇に注意する。すべての生活活動で熱中症の危険性あり。" },
    { wbgt: "25～28", level: "警戒", detail: "中等度以上の生活活動や、激しい運動をする際は、定期的に十分な休息を取り入れる。" },
    { wbgt: "～25", level: "注意", detail: "中等度以上の生活活動や、激しい運動をする際は、熱中症の危険性がある。" }
];

let currentWeatherData = null;
let lastRiskLevel = '';
let hourlyChart = null;

// --- DOM ELEMENTS ---
const appContainer = document.getElementById('app-container');
const cityInput = document.getElementById('cityInput');
const searchBtn = document.getElementById('searchBtn');
const gpsBtn = document.getElementById('gpsBtn');
const historyContainer = document.getElementById('historyContainer');
const loader = document.getElementById('loader');
const errorMessage = document.getElementById('error-message');
const errorText = document.getElementById('error-text');
const mainContent = document.getElementById('main-content');
const locationName = document.getElementById('locationName');
const currentWbgt = document.getElementById('currentWbgt');
const riskLevelText = document.getElementById('riskLevelText');
const currentTemp = document.getElementById('currentTemp');
const currentHumidity = document.getElementById('currentHumidity');
const currentDateTime = document.getElementById('currentDateTime');
const maxWbgtValue = document.getElementById('maxWbgtValue');
const maxWbgtTime = document.getElementById('maxWbgtTime');
const maxWbgtTemp = document.getElementById('maxWbgtTemp');
const maxWbgtHumidity = document.getElementById('maxWbgtHumidity');
const maxWbgtLabel = document.getElementById('maxWbgtLabel');
const hourlyForecast = document.getElementById('hourlyForecast');
const dailyForecast = document.getElementById('dailyForecast');
const gaugeMeter = document.getElementById('gaugeMeter');
const openModalBtn = document.getElementById('openModalBtn');
const safetyModal = document.getElementById('safetyModal');
const modalContent = document.getElementById('modalContent');
const toggleTableBtn = document.getElementById('toggleTableBtn');
const wbgtTableContainer = document.getElementById('wbgtTableContainer');
const wbgtTableHeader = document.getElementById('wbgtTableHeader');
const wbgtTableBody = document.getElementById('wbgtTableBody');
const tableCaret = document.getElementById('tableCaret');
const themeToggle = document.getElementById('theme-toggle');
const themeIcon = document.getElementById('theme-icon');
const toggleForecastViewBtn = document.getElementById('toggle-forecast-view');
const forecastViewIcon = document.getElementById('forecast-view-icon');
const hourlyChartContainer = document.getElementById('hourly-chart-container');
const hourlyCardsContainer = document.getElementById('hourly-cards-container');


// --- HELPER & CALCULATION FUNCTIONS ---
const calculateWBGT = (temp, rh) => {
    if (typeof temp !== 'number' || typeof rh !== 'number') return 0;
    const e = (rh / 100) * 6.105 * Math.exp((17.27 * temp) / (237.7 + temp));
    return 0.567 * temp + 0.393 * e + 3.94;
};

const getRiskInfo = (wbgt) => {
    if (wbgt >= 31) return RISK_LEVELS.DANGER;
    if (wbgt >= 28) return RISK_LEVELS.SEVERE_VIGILANCE;
    if (wbgt >= 25) return RISK_LEVELS.VIGILANCE;
    return RISK_LEVELS.CAUTION;
};

const getWeatherIconClass = (iconCode) => {
    const iconMap = {
        '01d': 'fas fa-sun text-yellow-500', '01n': 'fas fa-moon text-blue-300', '02d': 'fas fa-cloud-sun text-yellow-600', '02n': 'fas fa-cloud-moon text-blue-400',
        '03d': 'fas fa-cloud text-gray-500', '03n': 'fas fa-cloud text-gray-500', '04d': 'fas fa-cloud text-gray-500', '04n': 'fas fa-cloud text-gray-500',
        '09d': 'fas fa-cloud-showers-heavy text-blue-600', '09n': 'fas fa-cloud-showers-heavy text-blue-600', '10d': 'fas fa-cloud-sun-rain text-blue-500', '10n': 'fas fa-cloud-moon-rain text-blue-500',
        '11d': 'fas fa-bolt text-yellow-400', '11n': 'fas fa-bolt text-yellow-400', '13d': 'far fa-snowflake text-cyan-400', '13n': 'far fa-snowflake text-cyan-400',
        '50d': 'fas fa-smog text-gray-400', '50n': 'fas fa-smog text-gray-400',
    };
    return iconMap[iconCode] || 'fas fa-question-circle text-gray-400';
};

// --- UI UPDATE FUNCTIONS ---
const setUIState = (state) => {
    errorMessage.classList.add('hidden');
    if (state === 'loading') {
        loader.classList.remove('hidden');
        appContainer.classList.add('content-loading');
    } else {
        loader.classList.add('hidden');
        appContainer.classList.remove('content-loading');
        if (state === 'error') {
            errorMessage.classList.remove('hidden');
        } else if (state === 'success') {
            mainContent.classList.remove('hidden');
        }
    }
};

const displayError = (message) => {
    errorText.textContent = message;
    setUIState('error');
};

const updateGauge = (wbgt) => {
    const riskInfo = getRiskInfo(wbgt);
    const minWbgt = 15;
    const maxWbgt = 35;
    const percent = Math.max(0, Math.min(100, ((wbgt - minWbgt) / (maxWbgt - minWbgt)) * 100));
    gaugeMeter.style.strokeDashoffset = 100 - percent;
    gaugeMeter.style.stroke = riskInfo.color;
};

const generateWbgtTable = () => {
    const temps = Array.from({length: 11}, (_, i) => 25 + i);
    const humids = Array.from({length: 11}, (_, i) => 40 + i * 5);

    let headerHtml = '<tr><th class="border">温度℃ / 湿度%</th>';
    humids.forEach(h => headerHtml += `<th class="border">${h}</th>`);
    headerHtml += '</tr>';
    wbgtTableHeader.innerHTML = headerHtml;

    let bodyHtml = '';
    temps.forEach(t => {
        bodyHtml += '<tr>';
        bodyHtml += `<td class="border">${t}</td>`;
        humids.forEach(h => {
            const wbgt = calculateWBGT(t, h);
            const riskInfo = getRiskInfo(wbgt);
            bodyHtml += `<td class="border ${riskInfo.tableBgColor} font-medium">${wbgt.toFixed(1)}</td>`;
        });
        bodyHtml += '</tr>';
    });
    wbgtTableBody.innerHTML = bodyHtml;
};

const highlightCurrentCellInTable = (currentTemp, currentHumid) => {
    const oldHighlight = document.querySelector('.highlight-cell');
    if (oldHighlight) {
        oldHighlight.classList.remove('highlight-cell');
    }
    
    if (typeof currentTemp !== 'number' || typeof currentHumid !== 'number') return;

    const temps = Array.from({length: 11}, (_, i) => 25 + i);
    const humids = Array.from({length: 11}, (_, i) => 40 + i * 5);
    const closestTemp = temps.reduce((prev, curr) => (Math.abs(curr - currentTemp) < Math.abs(prev - currentTemp) ? curr : prev));
    const closestHumid = humids.reduce((prev, curr) => (Math.abs(curr - currentHumid) < Math.abs(prev - currentHumid) ? curr : prev));

    const tempIndex = temps.indexOf(closestTemp);
    const humidIndex = humids.indexOf(closestHumid);

    if (tempIndex >= 0 && humidIndex >= 0) {
        if (wbgtTableBody.rows[tempIndex] && wbgtTableBody.rows[tempIndex].cells[humidIndex + 1]) {
            const cell = wbgtTableBody.rows[tempIndex].cells[humidIndex + 1];
            cell.classList.add('highlight-cell');
        }
    }
};

const renderWeatherData = (data) => {
    currentWeatherData = data;
    // 1. Current Weather
    const currentMain = data.current.main || {};
    const currentTempVal = currentMain.temp || 0;
    const currentHumidityVal = currentMain.humidity || 0;
    const currentWbgtVal = calculateWBGT(currentTempVal, currentHumidityVal);
    const currentRiskInfo = getRiskInfo(currentWbgtVal);

    const observationTime = new Date(data.current.dt * 1000);
    const formattedTime = new Intl.DateTimeFormat('ja-JP', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' }).format(observationTime);
    currentDateTime.textContent = `${formattedTime} 時点`;

    locationName.textContent = data.locationName || '取得不可';
    currentWbgt.textContent = currentWbgtVal.toFixed(1);
    
    if (lastRiskLevel && lastRiskLevel !== currentRiskInfo.level) {
        riskLevelText.classList.add('animate-flash');
        riskLevelText.addEventListener('animationend', () => {
            riskLevelText.classList.remove('animate-flash');
        }, { once: true });
    }
    riskLevelText.textContent = currentRiskInfo.level;
    riskLevelText.className = `text-3xl font-bold mb-2 ${currentRiskInfo.textColor}`;
    lastRiskLevel = currentRiskInfo.level;

    currentTemp.textContent = `${Math.round(currentTempVal)}℃`;
    currentHumidity.textContent = `${Math.round(currentHumidityVal)}%`;
    updateGauge(currentWbgtVal);

    highlightCurrentCellInTable(currentTempVal, currentHumidityVal);
    if(data.isNewSearch) {
      addSearchToHistory({name: data.locationName, lat: data.current.coord.lat, lon: data.current.coord.lon});
    }

    // 2. Today's or Tomorrow's Max WBGT (9:00 - 17:00)
    const hourlyData = data.forecast.list || [];
    const now = new Date();
    
    let targetDate = new Date(now);
    let labelText = "今日の最高WBGT (9-17時)";

    if (now.getHours() >= 17) {
        targetDate.setDate(targetDate.getDate() + 1);
        labelText = `明日の最高WBGT (9-17時)`;
    }
    
    maxWbgtLabel.textContent = labelText;

    const targetStart = new Date(targetDate.getFullYear(), targetDate.getMonth(), targetDate.getDate(), 9, 0, 0);
    const targetEnd = new Date(targetDate.getFullYear(), targetDate.getMonth(), targetDate.getDate(), 17, 0, 0);

    const dayTimeForecasts = hourlyData.filter(item => {
        const itemDate = new Date(item.dt * 1000);
        return itemDate >= targetStart && itemDate <= targetEnd;
    });

    let maxWbgtInfo = { wbgt: -999, dt: 0, temp: 0, humidity: 0 };
    if (dayTimeForecasts.length > 0) {
        maxWbgtInfo = dayTimeForecasts.map(item => ({
            wbgt: calculateWBGT(item.main.temp, item.main.humidity),
            dt: item.dt,
            temp: item.main.temp,
            humidity: item.main.humidity
        })).reduce((max, current) => (current.wbgt > max.wbgt) ? current : max, maxWbgtInfo);
    }
    
    const isToday = now.getDate() === targetDate.getDate() && now.getMonth() === targetDate.getMonth();
    if (isToday && currentWbgtVal > maxWbgtInfo.wbgt && now >= targetStart && now <= targetEnd) {
        maxWbgtInfo = { wbgt: currentWbgtVal, dt: data.current.dt, temp: currentTempVal, humidity: currentHumidityVal };
    }

    if (maxWbgtInfo.dt > 0) {
        const maxTime = new Date(maxWbgtInfo.dt * 1000);
        maxWbgtValue.textContent = maxWbgtInfo.wbgt.toFixed(1);
        maxWbgtTime.textContent = `(${maxTime.getHours()}:00頃)`;
        maxWbgtTemp.textContent = `${Math.round(maxWbgtInfo.temp)}℃`;
        maxWbgtHumidity.textContent = `${Math.round(maxWbgtInfo.humidity)}%`;
    } else {
        maxWbgtValue.textContent = '--';
        maxWbgtTime.textContent = '(データなし)';
        maxWbgtTemp.textContent = `--℃`;
        maxWbgtHumidity.textContent = `--%`;
    }

    // 3. Hourly Forecast Cards
    hourlyForecast.innerHTML = '';
    const forecastItems = hourlyData.slice(0, 8);
    forecastItems.forEach((item, index) => {
        const date = new Date((item.dt || 0) * 1000);
        const main = item.main || {};
        const temp = main.temp || 0;
        const humidity = main.humidity || 0;
        const weather = (item.weather && item.weather.length > 0) ? item.weather[0] : {};
        const hourWbgt = calculateWBGT(temp, humidity);
        const hourRiskInfo = getRiskInfo(hourWbgt);
        
        const cardDiv = document.createElement('div');
        cardDiv.className = 'forecast-card flex-shrink-0 text-center p-3 rounded-lg bg-gray-100 w-24';
        cardDiv.innerHTML = `<p class="font-semibold text-gray-700">${date.getHours()}:00</p>
            <div class="my-2 space-y-1">
                <p class="font-bold text-lg ${hourRiskInfo.textColor}">${hourWbgt.toFixed(1)}<span class="text-xs">℃</span></p>
                <p class="text-sm text-gray-600">${Math.round(temp)}℃</p>
                <p class="text-sm text-blue-500">${humidity}%</p>
            </div>
            <i class="${getWeatherIconClass(weather.icon || '01d')} fa-lg"></i>`;
        hourlyForecast.appendChild(cardDiv);
        
        setTimeout(() => { cardDiv.classList.add('visible'); }, index * 100);
    });
    
    // 4. Hourly Forecast Chart
    renderHourlyChart(hourlyData.slice(0, 24));

    // 5. Daily Forecast
    dailyForecast.innerHTML = '';
    const dailyDataAggregated = {};
    const todayDateStr = new Date().toISOString().split('T')[0];
    hourlyData.forEach(item => {
        const dateStr = new Date(item.dt * 1000).toISOString().split('T')[0];
        if (!dailyDataAggregated[dateStr]) {
            dailyDataAggregated[dateStr] = { temps: [], humidities: [], weathers: [], dts: [] };
        }
        dailyDataAggregated[dateStr].temps.push(item.main.temp);
        dailyDataAggregated[dateStr].humidities.push(item.main.humidity);
        dailyDataAggregated[dateStr].weathers.push(item.weather[0]);
        dailyDataAggregated[dateStr].dts.push(item.dt);
    });

    Object.keys(dailyDataAggregated)
        .filter(dateStr => dateStr !== todayDateStr)
        .forEach((dateStr, index) => {
            const dayData = dailyDataAggregated[dateStr];
            const maxTemp = Math.max(...dayData.temps);
            const minTemp = Math.min(...dayData.temps);
            const maxTempIndex = dayData.temps.indexOf(maxTemp);
            const humidity = dayData.humidities[maxTempIndex] || dayData.humidities[0];
            const middayDt = dayData.dts.reduce((a, b) => Math.abs(new Date(b*1000).getHours() - 12) < Math.abs(new Date(a*1000).getHours() - 12) ? b : a);
            const weather = dayData.weathers[dayData.dts.indexOf(middayDt)] || dayData.weathers[0];
            const date = new Date(dayData.dts[0] * 1000);
            const dayOfWeek = ['日', '月', '火', '水', '木', '金', '土'][date.getDay()];
            const dailyWbgt = calculateWBGT(maxTemp, humidity);
            const dailyRiskInfo = getRiskInfo(dailyWbgt);

            const itemDiv = document.createElement('div');
            itemDiv.className = 'forecast-card flex items-center justify-between p-3 rounded-lg hover:bg-gray-50';
            itemDiv.innerHTML = `<div class="w-1/3 font-semibold text-gray-700">${date.getMonth() + 1}/${date.getDate()} (${dayOfWeek})</div>
                    <div class="w-1/3 flex justify-center items-center gap-3"><i class="${getWeatherIconClass(weather.icon)} fa-2x"></i><span class="font-bold text-lg ${dailyRiskInfo.textColor}">${dailyWbgt.toFixed(1)}℃</span></div>
                    <div class="w-1/3 text-right text-sm text-gray-600"><span class="text-red-500">${Math.round(maxTemp)}℃</span> / <span class="text-blue-500">${Math.round(minTemp)}℃</span></div>`;
            dailyForecast.appendChild(itemDiv);

            setTimeout(() => { itemDiv.classList.add('visible'); }, index * 100);
        });

    setUIState('success');
};

const renderHourlyChart = (hourlyData) => {
    if(hourlyChart) {
        hourlyChart.destroy();
    }
    const ctx = document.getElementById('hourlyChartCanvas').getContext('2d');
    const isDarkMode = document.documentElement.classList.contains('dark');
    const gridColor = isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
    const textColor = isDarkMode ? '#d1d5db' : '#374151';

    const labels = hourlyData.map(item => `${new Date(item.dt * 1000).getHours()}:00`);
    const wbgtData = hourlyData.map(item => calculateWBGT(item.main.temp, item.main.humidity).toFixed(1));
    const tempData = hourlyData.map(item => Math.round(item.main.temp));
    const humidityData = hourlyData.map(item => item.main.humidity);
    
    hourlyChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'WBGT (℃)',
                    data: wbgtData,
                    borderColor: '#f97316', // orange-500
                    backgroundColor: 'rgba(249, 115, 22, 0.1)',
                    yAxisID: 'y',
                    tension: 0.3,
                    fill: true,
                },
                {
                    label: '気温 (℃)',
                    data: tempData,
                    borderColor: '#ef4444', // red-500
                    backgroundColor: 'transparent',
                    yAxisID: 'y',
                    tension: 0.3,
                },
                {
                    label: '湿度 (%)',
                    data: humidityData,
                    borderColor: '#3b82f6', // blue-500
                    backgroundColor: 'transparent',
                    yAxisID: 'y1',
                    tension: 0.3,
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
                mode: 'index',
                intersect: false,
            },
            scales: {
                x: {
                    ticks: { color: textColor },
                    grid: { color: gridColor }
                },
                y: {
                    type: 'linear',
                    position: 'left',
                    title: { display: true, text: '温度 (℃)', color: textColor },
                    ticks: { color: textColor },
                    grid: { color: gridColor }
                },
                y1: {
                    type: 'linear',
                    position: 'right',
                    title: { display: true, text: '湿度 (%)', color: textColor },
                    min: 0,
                    max: 100,
                    ticks: { color: textColor },
                    grid: { drawOnChartArea: false }
                }
            },
            plugins: {
                legend: { labels: { color: textColor } }
            }
        }
    });
};

// --- SEARCH HISTORY ---
const getSearchHistory = () => JSON.parse(localStorage.getItem('wbgtSearchHistory') || '[]');

const addSearchToHistory = (location) => {
    let history = getSearchHistory();
    history = history.filter(item => item.name.toLowerCase() !== location.name.toLowerCase());
    history.unshift(location);
    localStorage.setItem('wbgtSearchHistory', JSON.stringify(history.slice(0, 5)));
    renderSearchHistory();
};

const renderSearchHistory = () => {
    historyContainer.innerHTML = '';
    const history = getSearchHistory();
    if (history.length > 0) {
        historyContainer.innerHTML += '<h4 class="w-full text-sm font-semibold text-gray-500 mb-1">検索履歴:</h4>';
        history.forEach(location => {
            const button = document.createElement('button');
            button.className = 'bg-gray-200 text-gray-700 px-3 py-1 rounded-full text-sm hover:bg-gray-300 transition-colors';
            button.textContent = location.name;
            button.onclick = () => {
                cityInput.value = location.name;
                fetchWeather(location.lat, location.lon, location.name, false);
            };
            historyContainer.appendChild(button);
        });
    }
};


// --- API FETCH LOGIC ---
const fetchWeather = async (lat, lon, locationName, isNewSearch = true) => {
    setUIState('loading');
    const currentWeatherUrl = `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&appid=${API_KEY}&units=metric&lang=ja`;
    const forecastUrl = `https://api.openweathermap.org/data/2.5/forecast?lat=${lat}&lon=${lon}&appid=${API_KEY}&units=metric&lang=ja`;

    try {
        const [currentResponse, forecastResponse] = await Promise.all([fetch(currentWeatherUrl), fetch(forecastUrl)]);
        if (!currentResponse.ok) throw new Error(`現在情報の取得に失敗: ${(await currentResponse.json()).message}`);
        if (!forecastResponse.ok) throw new Error(`予報情報の取得に失敗: ${(await forecastResponse.json()).message}`);
        
        const currentData = await currentResponse.json();
        const forecastData = await forecastResponse.json();
        
        if (!currentData.main || !forecastData.list) throw new Error("気象サービスから不完全なデータを受信しました。");
        
        renderWeatherData({ locationName, current: currentData, forecast: forecastData, isNewSearch });
    } catch (error) {
        console.error("Fetch Weather Error:", error);
        displayError(`天気情報の取得に失敗しました: ${error.message}`);
    }
};

const getCoordsByCity = async (city) => {
    const fetchCoords = async (query) => {
        const response = await fetch(`https://api.openweathermap.org/geo/1.0/direct?q=${encodeURIComponent(query)},JP&limit=1&appid=${API_KEY}`);
        if (!response.ok) throw new Error('地名からの座標取得に失敗しました。');
        return response.json();
    };

    try {
        let geoData = await fetchCoords(city);
        if (geoData.length === 0) {
            const match = city.match(/^(...??[都道府県])(.+)$/);
            if (match && match[2]) geoData = await fetchCoords(match[2]);
        }
        if (geoData.length === 0) throw new Error(`「${city}」が見つかりませんでした。`);
        
        const { lat, lon, local_names } = geoData[0];
        const locationName = (local_names && local_names.ja) ? local_names.ja : geoData[0].name;
        await fetchWeather(lat, lon, locationName);
    } catch (error) {
        console.error("Get Coords Error:", error);
        displayError(error.message);
    }
};

const getWeatherByGPS = async () => {
    setUIState('loading');
    try {
        if (!navigator.geolocation) {
            throw new Error("お使いのブラウザは位置情報取得に対応していません。");
        }
        if (!window.isSecureContext) {
             throw new Error("位置情報取得は安全な接続(HTTPS)でのみ利用可能です。");
        }

        const position = await new Promise((resolve, reject) => {
            navigator.geolocation.getCurrentPosition(resolve, reject, {
                enableHighAccuracy: false,
                timeout: 10000,
                maximumAge: 0,
            });
        });

        const { latitude, longitude } = position.coords;
        const response = await fetch(`https://api.openweathermap.org/geo/1.0/reverse?lat=${latitude}&lon=${longitude}&limit=1&appid=${API_KEY}`);
        const data = await response.json();
        const name = (data.length > 0 && data[0].local_names && data[0].local_names.ja) ? data[0].local_names.ja : '現在地';
        await fetchWeather(latitude, longitude, name);

    } catch (error) {
        let message;
        if (error.code) {
            switch (error.code) {
                case 1: message = "位置情報の利用が許可されていません。ブラウザまたは端末の設定をご確認ください。"; break;
                case 2: message = "位置情報が取得できませんでした。端末のGPSがオンになっているか確認し、電波の良い場所で再度お試しください。"; break;
                case 3: message = "位置情報の取得がタイムアウトしました。"; break;
                default: message = `不明なエラーが発生しました (コード: ${error.code})。`; break;
            }
        } else {
            message = error.message;
        }
        displayError(message);
    }
};


// --- EVENT LISTENERS & INITIALIZATION ---
const handleSearch = () => {
    if (cityInput.value.trim()) {
        getCoordsByCity(cityInput.value.trim());
    }
};

searchBtn.addEventListener('click', handleSearch);
cityInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') handleSearch(); });
gpsBtn.addEventListener('click', getWeatherByGPS);

toggleTableBtn.addEventListener('click', () => {
    wbgtTableContainer.classList.toggle('hidden');
    tableCaret.classList.toggle('fa-chevron-down');
    tableCaret.classList.toggle('fa-chevron-up');
});

modalContent.addEventListener('click', (e) => {
    if (e.target.closest('#closeModalBtn')) {
        safetyModal.classList.add('opacity-0', 'pointer-events-none');
    }
});

safetyModal.addEventListener('click', (e) => {
    if (e.target === safetyModal) {
        safetyModal.classList.add('opacity-0', 'pointer-events-none');
    }
});

openModalBtn.addEventListener('click', () => {
    let sourceTableHtml = '<table class="w-full source-table border-collapse"><thead><tr><th class="bg-gray-100">WBGT(℃)</th><th class="bg-gray-100">危険度</th><th class="bg-gray-100">注意事項</th></tr></thead><tbody>';
    SOURCE_DATA.forEach(row => {
        let riskInfo;
        switch(row.level) {
            case '危険': riskInfo = RISK_LEVELS.DANGER; break;
            case '厳重警戒': riskInfo = RISK_LEVELS.SEVERE_VIGILANCE; break;
            case '警戒': riskInfo = RISK_LEVELS.VIGILANCE; break;
            case '注意': riskInfo = RISK_LEVELS.CAUTION; break;
            default: riskInfo = { textColor: 'text-gray-700' };
        }
        sourceTableHtml += `<tr><td class="font-mono text-center">${row.wbgt}</td><td class="${riskInfo.textColor} font-bold text-center">${row.level}</td><td>${row.detail}</td></tr>`;
    });
    sourceTableHtml += '</tbody></table><p class="text-xs text-gray-500 mt-2">出典: 環境省 熱中症予防情報サイト</p>';

    modalContent.innerHTML = `
        <div class="flex justify-between items-center mb-4">
            <h2 class="text-2xl font-bold text-gray-800">凡例</h2>
            <button id="closeModalBtn" class="text-gray-500 hover:text-gray-800 text-2xl">&times;</button>
        </div>
        <div>
            ${sourceTableHtml}
        </div>`;

    safetyModal.classList.remove('opacity-0', 'pointer-events-none');
});

themeToggle.addEventListener('click', () => {
    const isDark = document.documentElement.classList.toggle('dark');
    localStorage.setItem('theme', isDark ? 'dark' : 'light');
    themeIcon.className = isDark ? 'fas fa-sun' : 'fas fa-moon';
    // グラフが描画済みであれば再描画してテーマを反映
    if(currentWeatherData) {
        renderHourlyChart(currentWeatherData.forecast.list.slice(0, 24));
    }
});

toggleForecastViewBtn.addEventListener('click', () => {
    hourlyChartContainer.classList.toggle('hidden');
    hourlyCardsContainer.classList.toggle('hidden');
    const isChartVisible = !hourlyChartContainer.classList.contains('hidden');
    forecastViewIcon.className = isChartVisible ? 'fas fa-th-large' : 'fas fa-chart-line';
});

window.addEventListener('load', () => {
    const savedTheme = localStorage.getItem('theme');
    if (savedTheme === 'dark' || (savedTheme !== 'light' && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
        document.documentElement.classList.add('dark');
        themeIcon.className = 'fas fa-sun';
    } else {
        document.documentElement.classList.remove('dark');
        themeIcon.className = 'fas fa-moon';
    }

    if (!API_KEY || API_KEY === "YOUR_API_KEY_HERE") return displayError("開発者エラー: APIキーが設定されていません。");
    generateWbgtTable();
    renderSearchHistory();
    
    const history = getSearchHistory();
    if (history.length > 0) {
        const lastLocation = history[0];
        cityInput.value = lastLocation.name;
        fetchWeather(lastLocation.lat, lastLocation.lon, lastLocation.name, false);
    } else {
        getCoordsByCity("東京");
    }
});

</script>
</body>
</html>
